# FastAPI Tour

> FastAPI is a modern, fast (high-performance) web framework for building APIs with Python 3.6+ based on standard Python type hints. (Sebastian Ramirez, creator of FastAPI)

Every framework is designed to make some operations easier - by features, omissions, and defaults.

### Advantages of FastAPI:
1. Performance - as fast as node.js and Go in some cases, unusual for python frameworks
2. Faster development - no sharp edges or oddities
3. Better code quality - type hinting and models help reduce bugs
4. Autogenerated documentation and test pages - much easier than hand-editing OpenAPI descriptions

FastAPI uses the following:
- Python type hints
- Starlette for the web machinery, including async support
- Pydantic for data definitions and validation
- Special integration to leverage and extend the others

## A FastAPI Application
```
pip install fastapi
pip install uvicorn
pip install httpie
pip install requests
pip install httpx
```

```
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi")
def greet():
    return "Hello? World?"
```
Here are some points to notice:
- *app* is the top-level FastAPI object that represents the whole web application
- *@app.get("/hi")* is a path decorator. It tells FastAPI the following: (1) a request for the URL "/hi" on this server should be directed to the following function; (2) This decorator applies only to the HTTP GET verb. You can also respond to a "/hi" URL sent with the other HTTP verbs (PUT, POST, etc.), each with a separate functions.
- *def greet()* is a path function - the main point of contact with HTTP requests and responses. In this example, it has no arguments, but the following sections show that there's much more under the FastAPI hood.

FastAPI itself does not include a web server but recommends Unicorn. You can start Uvicorn and the FastAPI web application in two ways: externally and internally.

```
uvicorn hello:app --reload
```

or we can put this command inside the python script.

Different ways to pass new parameter:
- In the URL path
- As a query parameter, after the ? in the URL
- In the HTTP body
- As an HTTP header

### URL path
```
@app.get("/hi/{who}")
def greet(who):
    return f"Hello? {who}?"
```

### Query parameters
*Query parameters* are the *name=value* strings after the ? in the URL, separated by & characters.
```
@app.get("/hi")
def greet(who):
    return f"Hello? {who}?"
```

### Body
In HTTP, GET is supposed to be *idempotent* - a computery term for ask the same question, get the same answer. *HTTP GET* is supposed to only return stuff. The request body is used to send stuff to the server when creating (POST) or updating (PUT or PATCH).

```
@app.post('/hi')
def greet(who:str = Body(embed=True)):
    return f"Hello? {who}?"
```

### HTTP Header
```
@app.post("/agent")
def get_agent(user_agent:str = Header()):
    return user_agent
```

### Multiple Request Data
You can use more than one of these methods in the same path function. That is, you can get data from the URL, query parameters, the HTTP body, HTTP headers, cookies, and so on. And you can write your own dependency fucntions that process and combine them in special ways, such as pagination and authentication.

### Which method is Best?
Recommendations:
- When passing arguments in the URL, following RESTful guidelines is standard practice
- Query strings are usually used to provide optional arguments, like pagination
- The body is usually used for larger inputs, like whole or partial models.

In each case, if you provide type hints in your data definitions, your arguments will be automatically type-checked by Pydantic. This ensures that they're both present and correct.

### HTTP Responses
By default, FastAPI converts whatever you return from your endpoint function to JSON; the HTTP response has a header line Content-type: application/json. So, although greet() function initially returns the string "Hello? World?", FastAPI converts it to JSON.

### Status Code
By default, FastAPI returns a 200 status code; exceptions raise 4xx codes.

In the path decorator, specify the HTTP status code that should be returned if all goes well (exceptions will generate their own codes and override it).

```
@app.get("/happy")
def happy(sad:str = Header, status_code=201):
    return f"{status_code}? :)"
```

### Headers
You can inject HTTP response headers.

```
@app.get("/header/{name}/{value}")
def header(name: str, value: str, response: Response):
    response.headers[name] = value
    return "normal body"
```

### Response Types
Response types (import these classes from fastapi.responses) include the following:
- JSONResponse (the default)
- HTMLResponse
- PlainTextResponse
- RedirectResponse
- FileResponse
- StreamingResponse

For other output formats (also known as *MIME types*), you can use a generic Response class, which needs the following:
- content - String or bytes
- media_type - the string MIME type
- status_code - HTTP integer status code
- headers - dict of strings

### Type Conversion
FastAPI uses an internal function called jsonable_encoder() to convert any data structure to a "JSONable" Python data structure, then calls the usual json.dumps() to turn that into a JSON string.

```
@pytest.fixture
def data():
    return datetime.datetime.now()


def test_json_dump(data):
    with pytest.raises(Exception):
        _ = json.dumps(data)


def test_encoder(data):
    out = jsonable_encoder(data)
    assert out
    json_out = json.dumps(out)
    assert json_out
```

### Model types and response_model
It's possible to have different classes with many of the same fields, except one is specialized for user input, one for output, and one for internal use. Some reasons for these variants could include the following:
- Remove some sensitive information from the output - like *deidentifying* personal medical data, if you've encountered Health Insurance Portability and Accountability Act (HIPAA) requirements
- Add fields to the user input (like a creation date and time)

